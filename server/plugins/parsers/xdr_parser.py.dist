# =================================================================================== #
#
#         FILE:  xdr_parser.py
#
#        USAGE:  xdr_parser.py [-h] [-v+] [--timeFormat] [--startDT] [--stopDT] <dataFile>
#
#  DESCRIPTION:  Parse the supplied NMEA XDR weather data and return the json-formatted
#                string used by OpenVDM as part of it's Data dashboard.
#
#      OPTIONS:  [-h] Return the help message.
#                [-v] Increase verbosity (default: warning)
#                [--timeFormat] date/time format to use when parsing datafile, default
#                               yyyy-mm-ddTHH:MM:SS.sssZ
#                [--startTS] optional start crop time (strptime format)
#                [--stopTS] optional stop crop time (strptime format)
#                <dataFile> Full or relative path of the data file to process.
#
# REQUIREMENTS:  Python3.8
#                Python Modules:
#                    numpy==1.19.5
#                    pandas==1.2.0
#                    PyYAML==5.3.1
#                    requests==2.25.1
#
#         BUGS:
#        NOTES:
#       AUTHOR:  Webb Pinner
#      COMPANY:  Capable Solutions
#      VERSION:  2.5
#      CREATED:  2016-08-29
#     REVISION:  2021-01-17
#
# LICENSE INFO:  Open Vessel Data Management v2.5 (OpenVDMv2)
#                Copyright (C) 2021 OceanDataRat.org
#
#    This program is free software: you can redistribute it and/or modify it under the
#    terms of the GNU General Public License as published by the Free Software
#    Foundation, either version 3 of the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, but WITHOUT ANY
#    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
#    PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License #    along with
#    this program.  If not, see <http://www.gnu.org/licenses/>.
#
# =================================================================================== #
import os
import sys
import csv
import copy
import json
import pandas as pd
import numpy as np
import argparse
import logging
from datetime import datetime

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(dirname(realpath(__file__))))))

from server.lib.openvdm_plugin import OpenVDMCSVParser
from server.lib.openvdm import OpenVDM_API

RAW_COLUMNS = ['date_time','hdr','C','air_temp','C2','TEMP','H','humidity','P','RH','P2','air_press','mB','BARO_checksum'] # OpenRVDAS style
# RAW_COLUMNS = ['date','time','hdr','C','air_temp','C2','TEMP','H','humidity','P','RH','P2','air_press','mB','BARO_checksum'] # SCS style
PROC_COLUMNS = ['date_time','air_press','air_temp','humidity']

ROUNDING = {
    'air_press': 1
    'air_temp': 2
    'humidity': 1
}

MIN_DEPTH = 0

MAX_DELTA_T = pd.Timedelta('10 seconds')

DEFAULT_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ" # ISO8601 Format, OpenRVDAS style
# DEFAULT_TIME_FORMAT = "%m/%d/%Y %H:%M:%S.%f" # SCS style


class XDRParser(OpenVDMCSVParser):

    def __init__(self, start_dt=None, stop_dt=None, time_format=DEFAULT_TIME_FORMAT, use_openvdm_api=True):
        super().__init__(start_dt=start_dt, stop_dt=stop_dt)
        self.raw_cols = RAW_COLS
        self.proc_cols = PROC_COLS
        self.time_format = time_format
        self.openvdm = OpenVDM_API() if use_openvdm_api else None


    def process_file(self, filePath):

        raw_into_df = { value: [] for key, value in enumerate(self.proc_cols) }

        logging.debug("Parsing data file...")
        errors = []
        try:
            with open(filePath, 'r') as csvfile:
                reader = csv.DictReader(csvfile, self.raw_cols)

                for lineno, line in enumerate(reader):

                    try:
                        date_time = line['date_time'] # OpenRVDAS style
                        #date_time = ' '.join([line['date'], line['time']]) # SCS style

                        air_temp = float(line['air_temp'])
                        air_pres = float(line['air_pres'])
                        humidity = float(line['humidity'])

                    except Exception as err:
                        errors.append(lineno)
                        logging.warning("Parsing error encountered on line {}".format(lineno))
                        logging.debug(line)
                        logging.debug(str(err))

                    else:
                        raw_into_df['date_time'].append(date_time)
                        raw_into_df['air_temp'].append(air_temp)
                        raw_into_df['air_pres'].append(air_pres)
                        raw_into_df['humidity'].append(humidity)

        except Exception as err:
            logging.error("Problem accessing input file: {}".format(filePath))
            logging.error(str(err))
            return None

        logging.debug("Finished parsing data file")
        
        # If no data ingested from file, quit
        if len(raw_into_df['date_time']) == 0:
            logging.warning("Dataframe is empty... quitting")
            return None

        # Build DataFrame
        logging.debug("Building dataframe from parsed data...")
        df_proc = pd.DataFrame(raw_into_df)

        # Convert Date/time column to datetime objects
        logging.debug("Converting data_time to datetime datatype...")
        
        df_proc['date_time'] = pd.to_datetime(df_proc['date_time'], format=self.time_format)

        # Optionally crop data by start/stop times
        if self.start_dt or self.stop_dt:
            logging.debug("Cropping data...")

            df_proc = self.crop_data(df_proc)

        # If the crop operation emptied the dataframe, quit
        if df_proc.shape[0] == 0:
            logging.warning("Cropped dataframe is empty... quitting")
            return None

        # Calculate deltaT column
        logging.debug('Building deltaT column...')
        df_proc = df_proc.join(df_proc['date_time'].diff().to_frame(name='deltaT'))

        logging.debug("Tabulating statistics...")
        self.add_row_validity_stat([len(df_proc), len(errors)])
        self.add_time_bounds_stat([df_proc['date_time'].min(), df_proc['date_time'].max()])
        self.add_bounds_stat([round(df_proc['deltaT'].min().total_seconds(),3), round(df_proc['deltaT'].max().total_seconds(),3)], 'DeltaT Bounds', 'seconds')
        self.add_value_validity_stat([len(df_proc[(df_proc['deltaT'] <= MAX_DELTA_T)]),len(df_proc[(df_proc['deltaT'] > MAX_DELTA_T)])], 'DeltaT Validity')
        self.add_bounds_stat([round(df_proc['air_temp'].min(),1), round(df_proc['air_temp'].max(),1)], 'Air Temp Bounds', 'C')
        self.add_bounds_stat([round(df_proc['air_pres'].min(),2), round(df_proc['air_pres'].max(),2)], 'Air Pressure Bounds', 'mBar')
        self.add_bounds_stat([round(df_proc['humidity'].min(),1), round(df_proc['humidity'].max(),1)], 'Hummidity Bounds', '%')
        
        logging.debug("Running quality tests...")
        # % of bad rows in datafile
        error_rate = len(errors) / (len(df_proc) + len(errors))
        if error_rate > .25:
            self.add_quality_test_failed("Rows")
        elif error_rate > .10:
            self.add_quality_test_warning("Rows")
        else:
            self.add_quality_test_passed("Rows")

        # % of time gaps in data
        error_rate = len(df_proc[(df_proc['deltaT'] > MAX_DELTA_T)]) / len(df_proc)
        if error_rate > .25:
            self.add_quality_test_failed("DeltaT")
        elif error_rate > .10:
            self.add_quality_test_warning("DeltaT")
        else:
            self.add_quality_test_passed("DeltaT")

        # set index
        logging.debug('Setting index...')
        df_proc = df_proc.set_index('date_time')

        # resample data
        logging.debug("Resampling data...")
        df_proc = self.resample_data(df_proc)

        # round data
        logging.debug("Rounding data: {}".format(ROUNDING))
        df_proc = self.round_data(df_proc, ROUNDING)

        # split data where there are gaps
        logging.debug("Building visualization data...")

        visualizerDataObj = {'data':[], 'unit':'', 'label':''}
        visualizerDataObj['data'] = json.loads(df_crop[['date_time','air_temp']].to_json(orient='values'))
        visualizerDataObj['unit'] = 'C'
        visualizerDataObj['label'] = 'Air Temperature'
        # output['visualizerData'].append(copy.deepcopy(visualizerDataObj))
        self.add_visualization_data(visualizerDataObj)

        visualizerDataObj['data'] = json.loads(df_crop[['date_time','air_pres']].to_json(orient='values'))
        visualizerDataObj['unit'] = 'mBar'
        visualizerDataObj['label'] = 'Air Pressure'
        # output['visualizerData'].append(copy.deepcopy(visualizerDataObj))
        self.add_visualization_data(visualizerDataObj)

        visualizerDataObj['data'] = json.loads(df_crop[['date_time','humidity']].to_json(orient='values'))
        visualizerDataObj['unit'] = '%'
        visualizerDataObj['label'] = 'Hummidity'
        # output['visualizerData'].append(copy.deepcopy(visualizerDataObj))
        self.add_visualization_data(visualizerDataObj)

        # send message about errors encountered to OpenVDM
        if self.openvdm is not None:
            self.openvdm.sendMsg('Parsing Error', 'Error(s) parsing datafile {} on row(s): {}'.format(filePath, ', '.join([str(error) for error in errors])))


# -------------------------------------------------------------------------------------
# Required python code for running the script as a stand-alone utility
# -------------------------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Parse NMEA XDR weather data')
    parser.add_argument('-v', '--verbosity', dest='verbosity',
                        default=0, action='count',
                        help='Increase output verbosity')
    parser.add_argument('--timeFormat', default=DEFAULT_TIME_FORMAT,
                        help='timestamp format, default: %(default)')
    parser.add_argument('--startDT', default=None,
                        type=lambda s: datetime.strptime(s, '%Y-%m-%dT%H:%M:%S.%fZ'),
                        help=' crop start timestamp (iso8601)')
    parser.add_argument('--stopDT', default=None,
                        type=lambda s: datetime.strptime(s, '%Y-%m-%dT%H:%M:%S.%fZ'),
                        help=' crop stop timestamp (iso8601)')
    parser.add_argument('dataFile', metavar='dataFile',
                        help='the raw data file to process')

    parsed_args = parser.parse_args()

    ############################
    # Set up logging before we do any other argument parsing (so that we
    # can log problems with argument parsing).
    
    LOGGING_FORMAT = '%(asctime)-15s %(levelname)s - %(message)s'
    logging.basicConfig(format=LOGGING_FORMAT)

    LOG_LEVELS = {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}
    parsed_args.verbosity = min(parsed_args.verbosity, max(LOG_LEVELS))
    logging.getLogger().setLevel(LOG_LEVELS[parsed_args.verbosity])

    ovdm_parser = XDRParser(start_dt=parsed_args.startDT, stop_dt=parsed_args.stopDT, time_format=parsed_args.timeFormat)

    try:
        logging.info("Processing file: {}".format(parsed_args.dataFile))
        ovdm_parser.process_file(parsed_args.dataFile)
        print(ovdm_parser.toJSON())
        logging.info("Done!")
    except Exception as err:
        logging.error(str(err))
        raise err
        sys.exit(1)


# =================================================================================== #
#
#         FILE:  met_parser.py
#
#        USAGE:  met_parser.py [-h] [-c] <dataFile>
#
#  DESCRIPTION:  Parse the supplied NMEA-formtted MET file (w/ SCS formatted timestamp)
#                and return the json-formatted string used by OpenVDM as part of it's
#                Data dashboard. 
#
#      OPTIONS:  [-h] Return the help message.
#                <dataFile> Full or relative path of the data file to process.
#
# REQUIREMENTS:  python2.7, Python Modules: sys, os, argparse, json, pandas
#
#         BUGS:
#        NOTES:
#       AUTHOR:  Webb Pinner
#      COMPANY:  Capable Solutions
#      VERSION:  1.0
#      CREATED:  2016-08-29
#     REVISION:  2016-12-29
#
# LICENSE INFO:  Open Vessel Data Management v2.2 (OpenVDMv2)
#                Copyright (C) 2017 OceanDataRat.org
#
#        NOTES:  Requires Pandas v0.18 or higher
#
#    This program is free software: you can redistribute it and/or modify it under the
#    terms of the GNU General Public License as published by the Free Software
#    Foundation, either version 3 of the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, but WITHOUT ANY
#    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
#    PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License #    along with
#    this program.  If not, see <http://www.gnu.org/licenses/>.
#
# =================================================================================== #
from __future__ import print_function
import pandas as pd
import numpy as np
import json
import argparse
import subprocess
import tempfile
import sys
import copy
import os
import shutil
import csv
from itertools import (takewhile,repeat)

# visualizerDataObj = {'data':[], 'unit':'', 'label':''}
# statObj = {'statName':'', 'statUnit':'', 'statType':'', 'statData':[]}
# qualityTestObj = {"testName": "", "results": ""}

RAW_COLUMNS = ['date','time','hdr','C','Air_Temperature_(C)','C2','TEMP','H','Relative_Humidity_(%)','P','RH','P2','Barometer_(mBar)','mB','BARO_cksum']
PROC_COLUMNS = ['date_time','Barometer_(mBar)','Air_Temperature_(C)','Relative_Humidity_(%)']
CROP_COLUMNS = ['date_time','Barometer_(mBar)','Air_Temperature_(C)','Relative_Humidity_(%)']

MAX_DELTA_T = pd.Timedelta('10 seconds')

RESAMPLE_INTERVAL = '1T' # 1 minute

DEBUG = False
CSVKIT = False

def debugPrint(*args, **kwargs):
    if DEBUG:
        errPrint(*args, **kwargs)

def errPrint(*args, **kwargs):
        print(*args, file=sys.stderr, **kwargs)


def rawincount(filename):
    f = open(filename, 'rb')
    bufgen = takewhile(lambda x: x, (f.read(1024*1024) for _ in repeat(None)))
    return sum( buf.count(b'\n') for buf in bufgen )

def csvCleanup(filepath):

    command = ['csvclean', filepath]
    errors = 0

    s = ' '
    debugPrint(s.join(command))

    proc = subprocess.Popen(command,stderr=subprocess.PIPE, stdout=subprocess.PIPE)
    out, err = proc.communicate()

    (dirname, basename) = os.path.split(filepath)

    debugPrint("Dirname:" + dirname)
    debugPrint("Basename:" + basename)

    outfile = os.path.join(dirname, os.path.splitext(basename)[0] + '_out.csv')
    errfile = os.path.join(dirname, os.path.splitext(basename)[0] + '_err.csv')

    debugPrint("Outfile: " + outfile)
    debugPrint("Errfile: " + errfile)

    if os.path.isfile(errfile):
        errors = rawincount(errfile)-1

    return (errors, outfile)

def parseFile(filePath):
    output = {}
    output['visualizerData'] = []
    output['qualityTests'] = []
    output['stats'] = []

    tmpdir = tempfile.mkdtemp()

    outfile = filePath
    errors = 0

    if CSVKIT:
        shutil.copy(filePath, tmpdir)
        (errors, outfile) = csvCleanup(os.path.join(tmpdir, os.path.basename(filePath)))
        debugPrint('Error: ', errors)

    rawIntoDf = {
        'date_time':[],
        'Barometer_(mBar)':[],
        'Air_Temperature_(C)':[],
        'Relative_Humidity_(%)':[],
    }

    csvfile = open(outfile, 'r')
    reader = csv.DictReader( csvfile, RAW_COLUMNS)

    for line in reader:

        try:

            line_date_time = line['date'] + ' ' + line['time']

            line_bar = float(line['Barometer_(mBar)'])
            line_air_temp = float(line['Air_Temperature_(C)'])
            line_humid = float(line['Relative_Humidity_(%)'])

        except:

            debugPrint('Parsing error: ',line)
            errors += 1

        else:
            rawIntoDf['date_time'].append(line_date_time)
            rawIntoDf['Barometer_(mBar)'].append(line_bar)
            rawIntoDf['Air_Temperature_(C)'].append(line_air_temp)
            rawIntoDf['Relative_Humidity_(%)'].append(line_humid)

    shutil.rmtree(tmpdir)

    if len(rawIntoDf['date_time']) == 0:
        return None

    df_proc = pd.DataFrame(rawIntoDf)

    df_proc['date_time'] = pd.to_datetime(df_proc['date_time'], infer_datetime_format=True)

    df_proc = df_proc.join(df_proc['date_time'].diff().to_frame(name='deltaT'))

    rowValidityStat = {'statName':'Row Validity', 'statType':'rowValidity', 'statData':[len(df_proc), errors]}
    output['stats'].append(rowValidityStat)

    barStat = {'statName': 'Barometer Bounds','statUnit': 'mBar', 'statType':'bounds', 'statData':[round(df_proc['Barometer_(mBar)'].min(),3), round(df_proc['Barometer_(mBar)'].max(),3)]}
    output['stats'].append(barStat)

    tempStat = {'statName': 'Air Temperature Bounds','statUnit': 'C', 'statType':'bounds', 'statData':[round(df_proc['Air_Temperature_(C)'].min(),3), round(df_proc['Air_Temperature_(C)'].max(),3)]}
    output['stats'].append(tempStat)

    humidStat = {'statName': 'Humidity Bounds','statUnit': '%', 'statType':'bounds', 'statData':[round(df_proc['Relative_Humidity_(%)'].min(),3), round(df_proc['Relative_Humidity_(%)'].max(),3)]}
    output['stats'].append(humidStat)

    deltaTStat = {"statName": "Delta-T Bounds","statUnit": "seconds","statType": "bounds","statData": [round(df_proc.deltaT.min().total_seconds(),3), round(df_proc.deltaT.max().total_seconds(),3)]}
    output['stats'].append(deltaTStat)

    deltaTValidityStat = {'statName':'Temporal Validity', 'statType':'valueValidity', 'statData':[len(df_proc[(df_proc['deltaT'] <= MAX_DELTA_T)]),len(df_proc[(df_proc['deltaT'] > MAX_DELTA_T)])]}
    output['stats'].append(deltaTValidityStat)

    rowQualityTest = {"testName": "Rows", "results": "Passed"}
    if rowValidityStat['statData'][1] > 0:
        if rowValidityStat['statData'][1]/rowValidityStat['statData'][0] > .10:
            rowQualityTest['results'] = "Failed"
        else:
            rowQualityTest['results'] = "Warning"
    output['qualityTests'].append(rowQualityTest)

    deltaTQualityTest = {"testName": "DeltaT", "results": "Passed"}
    if deltaTValidityStat['statData'][1] > 0:
        if deltaTValidityStat['statData'][1]/len(df_proc) > .10:
            deltaTQualityTest['results'] = "Failed"
        else:
            deltaTQualityTest['results'] = "Warning"
    output['qualityTests'].append(deltaTQualityTest)

    df_crop = df_proc[CROP_COLUMNS]

    df_crop = df_crop.set_index('date_time')

    df_crop = df_crop.resample(RESAMPLE_INTERVAL, label='right', closed='right').mean()

    df_crop = df_crop.reset_index()

    decimals = pd.Series([1, 2, 1, 1, 1, 1], index=['Barometer_(mBar)','Air_Temperature_(C)','Relative_Humidity_(%)','Vector_Wind_Speed_(m/s)','Vector_Wind_Direction_(degrees, Relative to Bow)','Scalar_Wind_Speed_(m/s)'])
    df_crop = df_crop.round(decimals)

    visualizerDataObj = {'data':[], 'unit':'', 'label':''}
    visualizerDataObj['data'] = json.loads(df_crop[['date_time','Barometer_(mBar)']].to_json(orient='values'))
    visualizerDataObj['unit'] = 'mBar'
    visualizerDataObj['label'] = 'Barometer'
    output['visualizerData'].append(copy.deepcopy(visualizerDataObj))

    visualizerDataObj['data'] = json.loads(df_crop[['date_time','Air_Temperature_(C)']].to_json(orient='values'))
    visualizerDataObj['unit'] = 'C'
    visualizerDataObj['label'] = 'Temperature'
    output['visualizerData'].append(copy.deepcopy(visualizerDataObj))

    visualizerDataObj['data'] = json.loads(df_crop[['date_time','Relative_Humidity_(%)']].to_json(orient='values'))
    visualizerDataObj['unit'] = '%'
    visualizerDataObj['label'] = 'Humidity'
    output['visualizerData'].append(copy.deepcopy(visualizerDataObj))

    return output

# -------------------------------------------------------------------------------------
# Main function of the script should it be run as a stand-alone utility.
# -------------------------------------------------------------------------------------
def main(argv):

    parser = argparse.ArgumentParser(description='Parse MET data')
    parser.add_argument('dataFile', metavar='dataFile', help='the raw data file to process')
    parser.add_argument('-d', '--debug', action='store_true', help=' display debug messages')
    parser.add_argument('-c', '--csvkit', action='store_true', help=' clean datafile using CSVKit')

    args = parser.parse_args()
    if args.debug:
        global DEBUG
        DEBUG = True
        debugPrint("Running in debug mode")

    if args.csvkit:
        global CSVKIT
        CSVKIT = True
        debugPrint("Using CSVKit to clean data file prior to processing")

    if not os.path.isfile(args.dataFile):
        sys.stderr.write('ERROR: File not found\n')
        sys.exit(1)

    jsonObj = parseFile(args.dataFile)
    if jsonObj:
        print(json.dumps(jsonObj))
        sys.exit(0)
    else:
        sys.exit(1)

# -------------------------------------------------------------------------------------
# Required python code for running the script as a stand-alone utility
# -------------------------------------------------------------------------------------
if __name__ == "__main__":
    main(sys.argv[1:])
