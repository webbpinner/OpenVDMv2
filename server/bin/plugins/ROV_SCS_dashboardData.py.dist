# =================================================================================== #
#
#         FILE:  ROV_SCS_dashboardData.py
#
#        USAGE:  ROV_SCS_dashboardData.py [-h] [--dataType] <dataFile>
#
#  DESCRIPTION:  This python script interprets raw files created by the SCS Data
#                Acquision System.  Depending on the command-line arguments, the script
#                returns the data type of the file or a sub-sampled and json-formatted
#                version of the original file to stdout.  The json-formatted file is
#                used by OpenVDM as part of it's Data dashboard. 
#
#      OPTIONS:  [-h] Return the help message.
#                [--dataType] Return the datatype of the file as defined in the
#                    fileTypeFilter array.
#                <dataFile> Full or relative path of the data file to process.
#
# REQUIREMENTS:  python2.7, Python Modules: sys, os, time, argparse, json, fnmatch, csv
#
#         BUGS:
#        NOTES:
#       AUTHOR:  Webb Pinner
#      COMPANY:  Capable Solutions
#      VERSION:  1.0
#      CREATED:  2016-10-23
#     REVISION:  2016-12-29
#
# LICENSE INFO:  Open Vessel Data Management 2.2 (OpenVDMv2)
#                Copyright (C) 2017 OceanDataRat.org
#
#    This program is free software: you can redistribute it and/or modify it under the
#    terms of the GNU General Public License as published by the Free Software
#    Foundation, either version 3 of the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, but WITHOUT ANY
#    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
#    PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License #    along with
#    this program.  If not, see <http://www.gnu.org/licenses/>.
#
# =================================================================================== #

from __future__ import print_function
import sys
import os
import time
import argparse
import json
import fnmatch
import csv
import subprocess
import requests

sys.path.insert(0,'/usr/local/bin')
import openvdm

SCRIPT_DIR = '/usr/local/bin/OVDM_dashboardDataScripts/'

SEALOG_SERVER_URL = 'http://10.23.9.57:8000/sealog-server'
SEALOG_JWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU5ODFmMTY3MjEyYjM0OGFlZDdmYTlmNSIsInNjb3BlIjpbImFkbWluIl0sInJvbGVzIjpbImFkbWluIiwiZXZlbnRfd2F0Y2hlciIsImV2ZW50X2xvZ2dlciIsImV2ZW50X21hbmFnZXIiLCJjcnVpc2VfbWFuYWdlciIsInRlbXBsYXRlX21hbmFnZXIiXSwiaWF0IjoxNjAwNjAxMjg5fQ.oDPjYxyUxovCXXXkV8N-xsNL4tfbHlHXDhyGQmMH2Zc'

# retrieve the OpenVDM configuration data
OVDM = openvdm.OpenVDM()

# -------------------------------------------------------------------------------------
# This array defines the various dataTypes collected by SCS and the cooresponding file
# regex expression.
# -------------------------------------------------------------------------------------
fileTypeFilters = [
    {"dataType":"ctd-rov",         "regex": "*SUBASTIAN/UDP-SB-CTD-RAW_*.Raw",                 "command": ['python', SCRIPT_DIR + 'ctd_rov_parser.py']},
    {"dataType":"gga-usbl-pri",    "regex": "*SBNAV/UDP-SB-USBL-PRI-GGA-RAW_*.Raw",            "command": ['python', SCRIPT_DIR + 'gga_parser.py']},
    {"dataType":"gga-usbl-sec",    "regex": "*SBNAV/UDP-SB-USBL-SEC-GGA-RAW_*.Raw",            "command": ['python', SCRIPT_DIR + 'gga_parser.py']},
    {"dataType":"o2-rov",          "regex": "*SUBASTIAN/UDP-SB-O2-PROC-O2_*.Raw",              "command": ['python', SCRIPT_DIR + 'o2_rov_parser.py']},
    {"dataType":"paro-rov",        "regex": "*SUBASTIAN/UDP-SB-Paro-Depth-RAW_*.Raw",          "command": ['python', SCRIPT_DIR + 'paro_parser.py']},
    {"dataType":"sprint",          "regex": "*SUBASTIAN/UDP-SB-SPRINT-RAW_*.Raw",              "command": ['python', SCRIPT_DIR + 'sprint_parser.py']},
]

DEBUG = False


def debugPrint(*args, **kwargs):
    if DEBUG:
        errPrint(*args, **kwargs)

def errPrint(*args, **kwargs):
        print(*args, file=sys.stderr, **kwargs)

# -------------------------------------------------------------------------------------
# Function to determine the datatype of the raw datafile.  If the datatype can not be
# determined, the function returns false
# -------------------------------------------------------------------------------------
def getDataType(filePath):

    for fileTypeFilter in fileTypeFilters:
        if fnmatch.fnmatch(filePath, fileTypeFilter['regex']):
            return fileTypeFilter['dataType']

    return False


# -------------------------------------------------------------------------------------
# Function to determine the command to run against a raw datafile to produce the
# dashboardData.  If the command can not be determined, the function returns false
# -------------------------------------------------------------------------------------
def getCommandByFile(filePath):

    for fileTypeFilter in fileTypeFilters:
        if fnmatch.fnmatch(filePath, fileTypeFilter['regex']):
            return fileTypeFilter['command']

    return False

    
# -------------------------------------------------------------------------------------
# Function to process the raw datafile and return a json-formatted representation.  If
# the datatype can not be determined, the function returns false.  With collection 
# systems that contain multiple dataTypes, this function may route the raw datafile to
# a dataType-specific processing sub-routine. 
# -------------------------------------------------------------------------------------
def getJsonObj(filePath):

    command = getCommandByFile(filePath)
    
    if not command:
        return False

    if DEBUG:
        command.append('-d')

    loweringID = getLoweringIDByDatafile(filePath)
    if loweringID:
        lowering = getLoweringByID(loweringID)

        if lowering:
            startTS = lowering['lowering_additional_meta']['milestones']['lowering_descending'] if lowering['lowering_additional_meta']['milestones']['lowering_descending'] else lowering.start_ts
            command.extend(['--startTS', startTS])

            stopTS = lowering['lowering_additional_meta']['milestones']['lowering_floats_on_surface'] if lowering['lowering_additional_meta']['milestones']['lowering_floats_on_surface'] else lowering.stop_ts
            command.extend(['--stopTS', stopTS])

    command.append(filePath)

    s = ' '
    debugPrint('Command: ' + s.join(command))

    proc = subprocess.Popen(command,stderr=subprocess.PIPE, stdout=subprocess.PIPE)
    out, err = proc.communicate()
    debugPrint('Err:',err)

    if out:
        return json.loads(out)
    
    return {'error': 'Unknown parsing error in ' + filePath + ' occurred<br>Command: ' + s.join(command)}


# -------------------------------------------------------------------------------------
#  Function to retrieve the sealog lowering record based on the lowering id
# -------------------------------------------------------------------------------------
def getLoweringByID(lowering_id):

  try:
    url = SEALOG_SERVER_URL + '/api/v1/lowerings?lowering_id=' + lowering_id
    r = requests.get(url, headers={"authorization": SEALOG_JWT})

    lowerings = json.loads(r.text)
    for lowering in lowerings:
      if lowering['lowering_id'] == lowering_id:
        # debugPrint(json.dumps(lowering, indent=2))
        return lowering
  except Exception as error:
    debugPrint(str(error))
    return None


# -------------------------------------------------------------------------------------
# Function to retrieve the loweringID based on the datafile.
# -------------------------------------------------------------------------------------
def getLoweringIDByDatafile(datafile):

    global OVDM
    shipboardDataWarehouseConfig = OVDM.getShipboardDataWarehouseConfig()
    cruiseID = OVDM.getCruiseID()
    baseDir = shipboardDataWarehouseConfig['shipboardDataWarehouseBaseDir']
    cruiseDir = os.path.join(baseDir, cruiseID)
    loweringBaseDir = os.path.join(cruiseDir, shipboardDataWarehouseConfig['loweringDataBaseDir'])

    try:
        loweringID = datafile.replace(loweringBaseDir,'').split('/')[1].split('_')[1]
        debugPrint('loweringID:', loweringID)
        return loweringID
    except:
        errPrint("could not parse path")

    return None


# -------------------------------------------------------------------------------------
# Main function of the script should it be run as a stand-alone utility.
# -------------------------------------------------------------------------------------
def main(argv):

    parser = argparse.ArgumentParser(description='SCS dataDashboard Processing Utilty')
    parser.add_argument('dataFile', metavar='dataFile', help='the raw data file to process')
    parser.add_argument('--dataType', action='store_true', help='return the dataType of the file')
    parser.add_argument('-d', '--debug', action='store_true', help=' display debug messages')

    args = parser.parse_args()
    if args.debug:
        global DEBUG
        DEBUG = True
        debugPrint("Running in debug mode")

    if not os.path.isfile(args.dataFile):
        sys.stderr.write('ERROR: File not found\n')
        sys.exit(1)
    elif os.stat(args.dataFile).st_size == 0:
        sys.stderr.write('File is empty')
        sys.exit(0)

    if args.dataType:
        dataType = getDataType(args.dataFile)
        if dataType:
            print(dataType)
            sys.exit(0)
        else:
            sys.exit(1)
    else:
        jsonObj = getJsonObj(args.dataFile)
        if jsonObj:
            print(json.dumps(jsonObj))
            sys.exit(0)
        else:
            sys.exit(1)

# -------------------------------------------------------------------------------------
# Required python code for running the script as a stand-alone utility
# -------------------------------------------------------------------------------------
if __name__ == "__main__":
    main(sys.argv[1:])
